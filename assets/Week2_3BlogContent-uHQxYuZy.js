import{d as m,u as r,b as d,c as o,a as n,e as s,n as i,f as a,o as g,_ as c}from"./index-BLDFxePB.js";import{H as l,p as x}from"./github-dark-DsXzy-Sw.js";const p={class:"leading-6 sm:leading-7 relative isolate max-w-full sm:max-w-3xl md:max-w-[800px] mx-auto px-3 sm:px-4 w-full text-slate-700 dark:text-gray-50 font-[ubuntu] font-feature-settings-kern font-feature-settings-liga font-feature-settings-calt"},b=m({__name:"Week2_3BlogContent",setup(u){const t=r();return l.registerLanguage("python",x),d(()=>{l.highlightAll()}),(h,e)=>(g(),o("div",p,[e[2]||(e[2]=n('<p class="font-bold text-xl sm:text-3xl md:text-3xl lg:text-4xl mt-6 mb-4 leading-tight py-2 px-2 rounded-md bg-gray-100/70 dark:bg-gray-900/40 w-full" data-v-6be094ec> GSoC&#39;25 Week-2 </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> Unfortunately, I wasn&#39;t able to write a blog post this week about my progress. That said, there hasn&#39;t been a lot of tangible output this week due to ongoing design discussions and some confusion. </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> Following our Week-1 meeting, I created a rough sketch of the design and asked for feedback. However, <strong class="font-bold" data-v-6be094ec>Oscar</strong> had a different approach in mind—specifically, he suggested we completely avoid introducing an Element class for now. This isn&#39;t necessarily contradictory to my initial proposal, since our primary goal is to treat the ring as a context (ctx) for constructing and manipulating elements. Hence, a dedicated element class might be unnecessary at this stage. </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> As I began working, <strong class="font-bold" data-v-6be094ec>Oscar</strong> shared a very interesting and elegant behavior from Flint&#39;s gr_series implementation. When a gr_series element is constructed using a DUP (dense univariate polynomial) list, and the list length is smaller than the ring&#39;s precision, <strong class="font-bold" data-v-6be094ec>Flint</strong> automatically treats it as a regular polynomial instead of a truncated series. This is mathematically more accurate, as there&#39;s no truncation happening and all coefficients are fully defined. </p>',4)),s("div",{class:i(["mb-4 sm:mb-6 rounded-lg p-4",{"bg-gray-50":a(t).theme==="light","bg-gray-900":a(t).theme==="dark"}])},[s("pre",{class:i(["text-sm font-mono whitespace-pre-wrap break-words",{"hljs-github":a(t).theme==="light","hljs-github-dark":a(t).theme==="dark"}])},[s("code",{class:i(["language-python",{"hljs-github":a(t).theme==="light","hljs-github-dark":a(t).theme==="dark"}])},`import flint.types._gr as gr

# Create a series ring with rational coefficients and precision 2
R = gr.gr_series_ctx.new(gr.gr_fmpq_ctx, 2)

# Create another series ring with rational coefficients and precision 4
R2 = gr.gr_series_ctx.new(gr.gr_fmpq_ctx, 4)

# Create a series: x + x^3 in ring R
a = R('x') + R('x')**3
print(a)  # Output: x + O(x^2)

# Convert series 'a' to ring R2 - notice it keeps original precision
converted_a = R2(a)
print(converted_a)  # Output: x + O(x^2)

# Multiply the converted series by x in R2
result1 = R2(a) * R2('x')
print(result1)  # Output: 0 + O(x^2)

# Create x in R2
x_in_R2 = R2('x')
print(x_in_R2)  # Output: x

# Multiply x by itself in R2
x_squared = R2('x') * R2('x')
print(x_squared)  # Output: x^2`,2)],2)],2),e[3]||(e[3]=n('<p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> This design is really clean and sets a good precedent, so I started working toward a similar behavior in our implementation. </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> However, on the last day of the week, <strong class="font-bold" data-v-6be094ec>Oscar</strong> shared a new design sketch that involved building our series ring directly on top of gr_series from <strong class="font-bold" data-v-6be094ec>Flint</strong>. This introduced some confusion for me, primarily because: </p><ul class="mb-4 sm:mb-6 ml-6 space-y-2 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7" data-v-6be094ec><li class="list-disc" data-v-6be094ec> gr_series currently lacks support for series expansions of <strong class="font-bold" data-v-6be094ec>Transcendental functions</strong>. </li><li class="list-disc" data-v-6be094ec> It is also somewhat unstable at the moment in <strong class="font-bold" data-v-6be094ec>python-Flint</strong>. </li></ul><p class="mb-6 sm:mb-8 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> While this direction is promising, I&#39;m still unsure if it aligns with our current goals, especially given those limitations. </p><p class="font-bold text-xl sm:text-3xl md:text-3xl lg:text-4xl mt-8 mb-4 leading-tight py-2 px-2 rounded-md bg-gray-100/70 dark:bg-gray-900/40 w-full" data-v-6be094ec> GSoC&#39;25 Week 3 </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> This week marked significant progress after the slow momentum in Week 2. I continued from where I left off and worked through key design questions that were previously unresolved. </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> There were two main agenda items this week: </p><ol class="mb-4 sm:mb-6 ml-6 space-y-2 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7" data-v-6be094ec><li class="list-decimal" data-v-6be094ec> Finalizing which series type to use from <strong class="font-bold" data-v-6be094ec>Flint</strong>. </li><li class="list-decimal" data-v-6be094ec>Clarifying how precision should be handled.</li></ol><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> As discussed earlier, gr_series is currently not well-supported in <strong class="font-bold" data-v-6be094ec>python-Flint</strong> and lacks APIs for <strong class="font-bold" data-v-6be094ec>Transcendental functions</strong>. Hence, we agreed to use fmpz_series and fmpq_series for now. In the future, once <strong class="font-bold" data-v-6be094ec>python-flint</strong> improves support for generic rings (gr_series), we can internally switch to it without affecting the public interface. This decouples implementation from usage, which is ideal. </p><p class="font-bold text-lg sm:text-2xl md:text-2xl lg:text-3xl mt-6 mb-3 leading-tight" data-v-6be094ec> Precision Design </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> The design around precision had some ambiguity. Here&#39;s the structure we eventually settled on: </p><ul class="mb-4 sm:mb-6 ml-6 space-y-2 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7" data-v-6be094ec><li class="list-disc" data-v-6be094ec> Each series can optionally have its own precision. </li><li class="list-disc" data-v-6be094ec>If a series has precision, we use it.</li><li class="list-disc" data-v-6be094ec> If none of the operands specify precision, we fall back to the ring&#39;s default precision. </li></ul><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> However, the tricky part arises when multiple series are involved in an operation. The natural instinct might be to return the result with the minimum precision among the inputs (i.e., min(p1, p2, ...)). But this doesn&#39;t always align with mathematical correctness. </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> Consider: </p>',14)),s("div",{class:i(["mb-4 sm:mb-6 rounded-lg p-4 border-l-4 border-indigo-500",{"bg-indigo-50":a(t).theme==="light","bg-indigo-900/20":a(t).theme==="dark"}])},e[0]||(e[0]=[n('<div class="font-mono text-base leading-relaxed" data-v-6be094ec><div class="mb-2" data-v-6be094ec><span class="text-indigo-600 dark:text-indigo-400 font-medium" data-v-6be094ec>s₁ =</span><span class="ml-2" data-v-6be094ec>1 + x + O(x²)</span></div><div class="mb-3" data-v-6be094ec><span class="text-indigo-600 dark:text-indigo-400 font-medium" data-v-6be094ec>s₂ =</span><span class="ml-2" data-v-6be094ec>x + O(x³)</span></div><div class="pt-2 border-t border-indigo-200 dark:border-indigo-700" data-v-6be094ec><span class="text-indigo-600 dark:text-indigo-400 font-medium" data-v-6be094ec>mul(s₁, s₂) =</span><span class="ml-2" data-v-6be094ec>?</span></div></div>',1)]),2),e[4]||(e[4]=s("p",{class:"mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]"}," If we use min(2, 3), the result is x + O(x²). But mathematically, we can compute up to x², so the correct result is: ",-1)),s("div",{class:i(["mb-4 sm:mb-6 rounded-lg p-4 border-l-4 border-green-500",{"bg-green-50":a(t).theme==="light","bg-green-900/20":a(t).theme==="dark"}])},e[1]||(e[1]=[s("div",{class:"font-mono text-base leading-relaxed"},[s("span",{class:"text-green-600 dark:text-green-400 font-medium"},"Result:"),s("span",{class:"ml-2 text-lg"},"x + x² + O(x³)")],-1)]),2),e[5]||(e[5]=n('<p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> While this richer result is desirable, implementing it is challenging. Doing so requires finding the first non-zero exponent of one series and combining it with the other&#39;s precision, which isn&#39;t straightforward, especially when series are sparse or symbolic. </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> Ultimately, we decided to follow Flint&#39;s behavior, which truncates to the minimum precision. While not always the most informative, it&#39;s consistent, simple, and mathematically valid (since truncation is deliberate and explicit). </p><p class="font-bold text-lg sm:text-2xl md:text-2xl lg:text-3xl mt-6 mb-3 leading-tight" data-v-6be094ec> Domain Separation </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> Another major improvement this week was the decision to separate rings based on ground domains (e.g., ℤ and ℚ). This avoids runtime errors when attempting unsupported operations like transcendental expansions over ℤ. </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> Instead of allowing these errors to propagate, the ring itself will not expose operations that are unsupported on its domain. This design is both safer and more user-friendly. Currently, ZZ and QQ domains are supported, and more will be added as <strong class="font-bold" data-v-6be094ec>python-flint</strong> evolves. </p><p class="font-bold text-lg sm:text-2xl md:text-2xl lg:text-3xl mt-6 mb-3 leading-tight" data-v-6be094ec> Code Structure </p><p class="mb-6 sm:mb-8 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-6be094ec> As the codebase grows, the series implementation will now live under a proper submodule (polys.series) instead of being a loose file in polys. This keeps things organized and aligns with SymPy&#39;s module structure. </p>',7))]))}}),v=c(b,[["__scopeId","data-v-6be094ec"]]);export{v as default};
