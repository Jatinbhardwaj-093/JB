import{d as l,u as n,b as m,c as o,a as e,e as t,n as g,f as r,g as i,o as b,_ as c}from"./index-ChG7xkqo.js";import{H as d,p as x}from"./github-dark-DsXzy-Sw.js";const p={class:"leading-6 sm:leading-7 relative isolate max-w-full sm:max-w-3xl md:max-w-[800px] mx-auto px-3 sm:px-4 w-full text-slate-700 dark:text-gray-50 font-[ubuntu] font-feature-settings-kern font-feature-settings-liga font-feature-settings-calt"},y={class:"mb-4 sm:mb-6"},v=l({__name:"Week5_6BlogContent",setup(u){const s=n();return d.registerLanguage("python",x),m(()=>{d.highlightAll()}),(f,a)=>(b(),o("div",p,[a[2]||(a[2]=e('<p class="font-bold text-xl sm:text-3xl md:text-3xl lg:text-4xl mt-6 mb-4 leading-tight py-2 px-2 rounded-md bg-gray-100/70 dark:bg-gray-800/40 w-full" data-v-988cb250> GSoC&#39;25 Week-5 </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-988cb250> This week was highly productive. The focus was on implementing efficient algorithms for series manipulation, particularly for operations that were previously missing or handled suboptimally in the <span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>dense*</span> modules of SymPy. </p><div class="mb-4 sm:mb-6" data-v-988cb250><h2 class="font-bold text-lg sm:text-xl md:text-2xl mb-3" data-v-988cb250> Implemented Operations </h2><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-988cb250> We added optimized arithmetic methods for: </p><ul class="list-disc pl-6 mb-4 space-y-2" data-v-988cb250><li class="text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7" data-v-988cb250><strong data-v-988cb250>Multiplication</strong>: Uses the basic Cauchy product for small series (<span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>n &lt; 100</span>), and Karatsuba multiplication with adaptive truncation for larger series. </li><li class="text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7" data-v-988cb250><strong data-v-988cb250>Power</strong>: Uses recursive exponentiation-by-squaring, with truncation at each recursive step. </li><li class="text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7" data-v-988cb250><strong data-v-988cb250>Multiplicative Inverse</strong>: Already available via <span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>dup_revert</span> in <span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>densetools.py</span>. </li></ul></div><div class="mb-4 sm:mb-6" data-v-988cb250><h2 class="font-bold text-lg sm:text-xl md:text-2xl mb-3" data-v-988cb250>Composition</h2><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-988cb250> To compute series composition, the existing Horner&#39;s method (<span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>dup_compose</span>) was not sufficient for performance. We introduced a faster approach in <span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>dup_series_compose</span>, using a divide-and-conquer strategy with truncation enabled. While its optimality is still under evaluation, it performs reasonably well for general-purpose use. </p></div><div class="mb-4 sm:mb-6" data-v-988cb250><h2 class="font-bold text-lg sm:text-xl md:text-2xl mb-3" data-v-988cb250> Compositional Inverse (Series Reversion) </h2><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-988cb250> We implemented the <strong data-v-988cb250>Fast Lagrange Inversion algorithm</strong>, proposed by Fredrik Johansson in his paper <a href="https://fredrikj.net/math/reversion.pdf" class="text-blue-600 dark:text-blue-400 hover:underline" target="_blank" rel="noopener noreferrer" data-v-988cb250>A Fast Algorithm for Reversion of Power Series</a>. This algorithm avoids Newton iteration by precomputing powers of <span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>h, h², h³, ..., hᵐ</span>, allowing efficient coefficient extraction using Lagrange&#39;s formula. </p></div>',5)),t("div",y,[a[1]||(a[1]=e('<h2 class="font-bold text-lg sm:text-xl md:text-2xl mb-3" data-v-988cb250> Why Fast Lagrange Inversion? </h2><ul class="list-disc pl-6 mb-4 space-y-2" data-v-988cb250><li class="text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7" data-v-988cb250> Avoids redundancy by directly using the Lagrange inversion formula </li><li class="text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7" data-v-988cb250> Reduces overhead compared to Newton iteration, particularly for large series </li><li class="text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7" data-v-988cb250> Achieves speedup factors of <strong data-v-988cb250>1.2× to 1.5×</strong> over classical methods </li><li class="text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7" data-v-988cb250> Works well with coefficient rings like ℤ and ℚ </li></ul>',2)),t("div",{class:g(["mb-4 sm:mb-6 rounded-lg p-4 border-l-4 border-blue-500",{"bg-blue-50":r(s).theme==="light","bg-blue-900/20":r(s).theme==="dark"}])},a[0]||(a[0]=[t("p",{class:"text-sm sm:text-base italic"},[i(" As Johansson writes in his paper:"),t("br"),t("em",null,'"Our algorithm can be viewed as a baby-step giant-step version of the Lagrange inversion formula, avoiding Newton iteration entirely (apart from a single O(M(n)) reciprocal computation)."')],-1)]),2)]),a[3]||(a[3]=e('<div class="mb-4 sm:mb-6" data-v-988cb250><h2 class="font-bold text-lg sm:text-xl md:text-2xl mb-3" data-v-988cb250> Benchmarks from the Paper </h2><h3 class="font-semibold text-base sm:text-lg mb-3" data-v-988cb250> Timing Comparison Over ℤ/pℤ </h3><div class="overflow-x-auto mb-4" data-v-988cb250><table class="min-w-full border-collapse border border-gray-300 dark:border-gray-600" data-v-988cb250><thead data-v-988cb250><tr class="bg-gray-100 dark:bg-gray-800" data-v-988cb250><th class="border border-gray-300 dark:border-gray-600 px-4 py-2 text-left" data-v-988cb250> n </th><th class="border border-gray-300 dark:border-gray-600 px-4 py-2 text-left" data-v-988cb250> Lagrange Inversion </th><th class="border border-gray-300 dark:border-gray-600 px-4 py-2 text-left" data-v-988cb250> Newton + BK 2.1 </th><th class="border border-gray-300 dark:border-gray-600 px-4 py-2 text-left" data-v-988cb250> Fast Lagrange Inversion </th></tr></thead><tbody data-v-988cb250><tr data-v-988cb250><td class="border border-gray-300 dark:border-gray-600 px-4 py-2 font-mono" data-v-988cb250> 10² </td><td class="border border-gray-300 dark:border-gray-600 px-4 py-2" data-v-988cb250> 2.8 ms </td><td class="border border-gray-300 dark:border-gray-600 px-4 py-2" data-v-988cb250> 0.92 ms </td><td class="border border-gray-300 dark:border-gray-600 px-4 py-2 font-semibold text-green-600 dark:text-green-400" data-v-988cb250> 0.54 ms </td></tr><tr class="bg-gray-50 dark:bg-gray-800/50" data-v-988cb250><td class="border border-gray-300 dark:border-gray-600 px-4 py-2 font-mono" data-v-988cb250> 10³ </td><td class="border border-gray-300 dark:border-gray-600 px-4 py-2" data-v-988cb250> 690 ms </td><td class="border border-gray-300 dark:border-gray-600 px-4 py-2" data-v-988cb250> 66 ms </td><td class="border border-gray-300 dark:border-gray-600 px-4 py-2 font-semibold text-green-600 dark:text-green-400" data-v-988cb250> 45 ms </td></tr><tr data-v-988cb250><td class="border border-gray-300 dark:border-gray-600 px-4 py-2 font-mono" data-v-988cb250> 10⁴ </td><td class="border border-gray-300 dark:border-gray-600 px-4 py-2" data-v-988cb250> 110 s </td><td class="border border-gray-300 dark:border-gray-600 px-4 py-2" data-v-988cb250> 3300 ms </td><td class="border border-gray-300 dark:border-gray-600 px-4 py-2 font-semibold text-green-600 dark:text-green-400" data-v-988cb250> 2100 ms </td></tr><tr class="bg-gray-50 dark:bg-gray-800/50" data-v-988cb250><td class="border border-gray-300 dark:border-gray-600 px-4 py-2 font-mono" data-v-988cb250> 10⁵ </td><td class="border border-gray-300 dark:border-gray-600 px-4 py-2" data-v-988cb250> 12100 s </td><td class="border border-gray-300 dark:border-gray-600 px-4 py-2" data-v-988cb250> 144000 ms </td><td class="border border-gray-300 dark:border-gray-600 px-4 py-2 font-semibold text-green-600 dark:text-green-400" data-v-988cb250> 85000 ms </td></tr></tbody></table></div><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-988cb250> The Fast Lagrange algorithm consistently outperformed naive Lagrange inversion and Newton iteration with BK 2.1, making it a strong default candidate for series reversion. </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-988cb250> Additionally, a helper function was implemented for small precision reversion (<span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>n ≥ 4</span>). This delivers up to <strong data-v-988cb250>60× speedup</strong> compared to general algorithms. While currently limited to <span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>n = 4</span>, we plan to extend support to <span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>n = 5, 6, ...</span> in the future. </p></div><div class="mb-4 sm:mb-6" data-v-988cb250><h2 class="font-bold text-lg sm:text-xl md:text-2xl mb-3" data-v-988cb250> Convenience Utilities </h2><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-988cb250> Three helper functions were added to <span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>densbasic.py</span>: </p><ul class="list-disc pl-6 mb-4 space-y-2" data-v-988cb250><li class="text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7" data-v-988cb250><span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>dup_truncate</span>: Efficiently truncate series to a given length </li><li class="text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7" data-v-988cb250><span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>dup_from_list</span>: Construct a series from a coefficient list </li><li class="text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7" data-v-988cb250><span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>dup_print</span>: A prototype function for formatted series output (to be improved later) </li></ul></div><div class="mb-8 sm:mb-10" data-v-988cb250><h2 class="font-bold text-lg sm:text-xl md:text-2xl mb-3" data-v-988cb250>Final Note</h2><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-988cb250> All of the above was merged in <a href="https://github.com/sympy/sympy/pull/28208" class="text-blue-600 dark:text-blue-400 hover:underline" target="_blank" rel="noopener noreferrer" data-v-988cb250>gh-28208</a>, building a robust foundation for further development of symbolic series arithmetic. </p></div><p class="font-bold text-xl sm:text-3xl md:text-3xl lg:text-4xl mt-8 mb-4 leading-tight py-2 px-2 rounded-md bg-gray-100/70 dark:bg-gray-800/40 w-full" data-v-988cb250> GSoC&#39;25 Week-6 </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-988cb250> This week was a bit slower due to a scheduled quiz. Still, I was able to contribute meaningful changes to the Series Ring PR. </p><div class="mb-4 sm:mb-6" data-v-988cb250><h2 class="font-bold text-lg sm:text-xl md:text-2xl mb-3" data-v-988cb250>Progress</h2><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-988cb250> Following the merge of <a href="https://github.com/sympy/sympy/pull/28208" class="text-blue-600 dark:text-blue-400 hover:underline" target="_blank" rel="noopener noreferrer" data-v-988cb250>gh-28208</a>, we introduced support for: </p><ul class="list-disc pl-6 mb-4 space-y-2" data-v-988cb250><li class="text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7" data-v-988cb250><strong data-v-988cb250>Composition</strong></li><li class="text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7" data-v-988cb250><strong data-v-988cb250>Inverse</strong></li><li class="text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7" data-v-988cb250><strong data-v-988cb250>Reversion</strong></li></ul><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-988cb250> Each of these methods relies on new <span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>dup_series_*</span> routines that are integrated with the Series Ring class logic. </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-988cb250> Additionally, a PR related to <strong data-v-988cb250>type annotations</strong> for the polynomial domain structure was merged: <a href="https://github.com/sympy/sympy/pull/28177" class="text-blue-600 dark:text-blue-400 hover:underline" target="_blank" rel="noopener noreferrer" data-v-988cb250>gh-28177</a>. This improves type safety for series operations, as we use the <span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>DUP</span> representation — a list of ground domain coefficients. For example: </p><ul class="list-disc pl-6 mb-4 space-y-2" data-v-988cb250><li class="text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7" data-v-988cb250><span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>DUP[MPZ]</span> for integers (ℤ) </li><li class="text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7" data-v-988cb250><span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>DUP[MPQ]</span> for rationals (ℚ) </li></ul><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-988cb250> This allows solid and specific type checking, moving away from loosely typed <span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>Any</span> or generic <span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>TypeVar</span>. </p></div><div class="mb-4 sm:mb-6" data-v-988cb250><h2 class="font-bold text-lg sm:text-xl md:text-2xl mb-3" data-v-988cb250> Testing Updates </h2><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-988cb250> A new structure was proposed for test files. Instead of using <span class="font-mono bg-gray-100 dark:bg-gray-800 px-1 rounded" data-v-988cb250>pytest.mark.parametrize</span>, we now leverage <strong data-v-988cb250>pytest fixtures</strong> for greater modularity and clarity. </p></div><div class="mb-6 sm:mb-8" data-v-988cb250><hr class="border-gray-300 dark:border-gray-600 my-6" data-v-988cb250><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-988cb250> I&#39;m hoping to wrap up minor cleanups next week and get the Series Ring PR finalized and merged. After that, I plan to focus on expanding support for transcendental functions. </p></div>',8))]))}}),k=c(v,[["__scopeId","data-v-988cb250"]]);export{k as default};
