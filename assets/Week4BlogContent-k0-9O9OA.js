import{d as l,u as i,b as d,c as g,a as n,e as s,n as m,f as t,o,_ as x}from"./index-lBR4UCQW.js";import{H as r,p}from"./github-dark-DsXzy-Sw.js";const c={class:"leading-6 sm:leading-7 relative isolate max-w-full sm:max-w-3xl md:max-w-[800px] mx-auto px-3 sm:px-4 w-full text-slate-700 dark:text-gray-50 font-[ubuntu] font-feature-settings-kern font-feature-settings-liga font-feature-settings-calt"},h={class:"mb-4 sm:mb-6"},b={class:"mb-4 sm:mb-6"},u=l({__name:"Week4BlogContent",setup(f){const e=i();return r.registerLanguage("python",p),d(()=>{r.highlightAll()}),(w,a)=>(o(),g("div",c,[a[7]||(a[7]=n('<p class="font-bold text-xl sm:text-3xl md:text-3xl lg:text-4xl mt-6 mb-4 leading-tight py-2 px-2 rounded-md bg-gray-100/70 dark:bg-gray-900/40 w-full" data-v-0e00738e> GSoC&#39;25 Week-4 </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-0e00738e> This week was quite productive, especially around testing and fixing methods. </p><div class="mb-4 sm:mb-6" data-v-0e00738e><h2 class="font-bold text-lg sm:text-xl md:text-2xl mb-3" data-v-0e00738e>Progress</h2><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-0e00738e> I mainly focused on refining how equality is determined for power series. While the work is still in the development phase and hasn&#39;t been reviewed yet, I made substantial progress. </p></div>',3)),s("div",h,[a[0]||(a[0]=n('<h2 class="font-bold text-lg sm:text-xl md:text-2xl mb-3" data-v-0e00738e> The Challenge: Power Series Equality </h2><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-0e00738e> Equality for power series is surprisingly tricky. </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-0e00738e> Unlike polynomials—where we can directly compare coefficients of matching exponents—power series involve truncation, which hides terms beyond a certain degree. This makes it impossible to be certain about what comes after the truncation point. </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-0e00738e> Example: <strong class="font-mono bg-gray-100 dark:bg-gray-900 px-1 rounded" data-v-0e00738e>s = 1 + x^2 + 4x^3 + 7x^4 + O(x^5)</strong></p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-0e00738e> At a glance, comparing s with a longer or differently truncated series might seem like a match, but we cannot guarantee what happens after x^4. </p><p class="mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]" data-v-0e00738e> To handle this correctly, I studied how gr_series from <strong data-v-0e00738e>python-flint</strong> behaves: </p>',6)),s("div",{class:m(["mb-4 sm:mb-6 rounded-lg p-4",{"bg-gray-100":t(e).theme==="light","bg-gray-900":t(e).theme==="dark"}])},[s("pre",{class:m(["text-sm font-mono whitespace-pre-wrap break-words",{"hljs-github":t(e).theme==="light","hljs-github-dark":t(e).theme==="dark"}])},[s("code",{class:m(["language-python",{"hljs-github":t(e).theme==="light","hljs-github-dark":t(e).theme==="dark"}])},`import flint.types._gr as gr
R = gr.gr_series_ctx.new(gr.gr_fmpq_ctx, 4)
R2 = gr.gr_series_ctx.new(gr.gr_fmpq_ctx, 10)
x, x2 = R('x'), R2('x')

s = 1 + x**2 + x**4
s2 = 1 + x2**2 + x2**4 + x2**10
R2(s) == s2  # returns None`,2)],2)],2),a[1]||(a[1]=s("p",{class:"mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]"}," As expected, it returns None, indicating uncertainty due to the truncation mismatch. ",-1)),a[2]||(a[2]=s("p",{class:"mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]"},' But if the "extra" terms go beyond the shared precision and do change the lower-degree part, equality must return False: ',-1)),s("div",{class:m(["mb-4 sm:mb-6 rounded-lg p-4",{"bg-gray-100":t(e).theme==="light","bg-gray-900":t(e).theme==="dark"}])},[s("pre",{class:m(["text-sm font-mono whitespace-pre-wrap break-words",{"hljs-github":t(e).theme==="light","hljs-github-dark":t(e).theme==="dark"}])},[s("code",{class:m(["language-python",{"hljs-github":t(e).theme==="light","hljs-github-dark":t(e).theme==="dark"}])},`s2 = 1 + x2**2 + x2**3 + x2**10
R2(s) == s2  # returns False`,2)],2)],2),a[3]||(a[3]=s("p",{class:"mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]"}," This confirms the rule: if two series differ within the shared precision, they are unequal. If they match, but one has unknown values beyond that range, we return None (indeterminate). ",-1))]),s("div",b,[a[4]||(a[4]=s("h2",{class:"font-bold text-lg sm:text-xl md:text-2xl mb-3"}," My Implementation ",-1)),a[5]||(a[5]=s("p",{class:"mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]"}," Although the current implementation may not be pretty, it does reflect this behavior accurately: ",-1)),s("div",{class:m(["mb-4 sm:mb-6 rounded-lg p-4",{"bg-gray-100":t(e).theme==="light","bg-gray-900":t(e).theme==="dark"}])},[s("pre",{class:m(["text-sm font-mono whitespace-pre-wrap break-words",{"hljs-github":t(e).theme==="light","hljs-github-dark":t(e).theme==="dark"}])},[s("code",{class:m(["language-python",{"hljs-github":t(e).theme==="light","hljs-github-dark":t(e).theme==="dark"}])},`def _useries_equality(s1: USeries[T], s2: USeries[T], dom: Domain) -> bool | None:
    """Check if two power series are equal."""
    coeffs1, prec1 = s1
    coeffs2, prec2 = s2

    # if elif handling the exact polynomial case here
    if prec1 is None and prec2 is None:
        return s1 == s2
    elif prec1 is None or prec2 is None:
        return False
    else:
        min_prec = min(prec1, prec2)

    # checking for minprec from both series truncation
    coeffs1 = dup_slice(coeffs1, 0, min_prec, dom)
    coeffs2 = dup_slice(coeffs2, 0, min_prec, dom)
    if coeffs1 != coeffs2:
        return False
    return None`,2)],2)],2),a[6]||(a[6]=s("p",{class:"mb-3 sm:mb-4 text-sm sm:text-base md:text-base lg:text-lg leading-6 sm:leading-7 md:leading-7 tracking-[0.01em] sm:tracking-[0.015em] text-wrap-pretty max-w-full sm:max-w-[95%] md:max-w-[90%]"}," It checks for equality up to the shared truncation precision, returns False if a conflict is found, and None if values match but further terms are unknown. ",-1))])]))}}),v=x(u,[["__scopeId","data-v-0e00738e"]]);export{v as default};
